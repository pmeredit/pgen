use std::str::FromStr;
use ast::{Expr, Opcode, Let, Cond, Switch};

grammar;


match {
    //no idea why this regexp won't work
    //r#"('([^'\\]|\\.)*')|("([^"\\]|\\.)*")"# => STRING,
    r#"'([^'\\]|\\.)*'"#                       => SINGLESTRING,
    r#""([^"\\]|\\.)*""#  	               => DOUBLESTRING,
    r"-?[0-9]+"                                => INT,
    r"-?([0-9]*[.][0-9]+)"                     => FLOAT,
    r"\$\w+"                                   => COLUMN,
    r"[a-zA-Z_]\w*"                            => VARIABLE,
    "let","=", "in", 
    "if", "then", "else",
    "switch", "=>", "default",
    "{","}","[","]", "(", ")",
    "+","-","*","/",":",";",",",
    "<=", ">=", "==", "!=",
    "and", "or", "null", "true", "false"
}

pub Pipeline = List<PipelineItem, ";">;

pub TopExpr: Box<Expr> =  { 
    "let" <a:Assignments> "in" <e:TopExpr> => 
 	Box::new(Expr::Let(
	    Box::new(Let{assignments: a, expr: e}))),
    "if" <i:OrExpr> "then" <t:OrExpr> "else" <e:OrExpr> =>
     	Box::new(Expr::Cond(
	    Box::new(Cond{cond:i, then:t, otherwise:e}))),
    "switch" "{"  <c:Cases> "default" ":" <d:OrExpr> "}" =>
    	Box::new(Expr::Switch(
	    Box::new(Switch{cases:c, default:d}))),
    OrExpr,
};

PipelineItem: (String, Box<Expr>) = {
    <id:ID> ":" <o:TopExpr> => (id, o)
};


Assignment: (String, Box<Expr>) = {
    <id:ID> "=" <val:TopExpr> => (id, val)
};

ObjItem: (String, Box<Expr>) = {
    <k:Str> ":" <v:TopExpr> => (k, v)
};

Case: (Box<Expr>, Box<Expr>) = {
    <c:OrExpr> "=>" <e:TopExpr> => (c, e)
};

List<T, Sep>: Vec<T> = { 
    <v:(<T> Sep)*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Assignments = List<Assignment, ",">;
Args        = List<TopExpr, ",">;
Cases       = List<Case, ",">;
ObjItems    = List<ObjItem, ",">;

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier
};

OrExpr      = Tier<OrOp,      AndExpr     >;
AndExpr     = Tier<AndOp,     CompareExpr >;
CompareExpr = Tier<CompareOp, AddExpr     >;
AddExpr     = Tier<AddOp,     MulExpr     >;
MulExpr     = Tier<MulOp,     BottomExpr  >;

OrOp: Opcode = {
    "or" => Opcode::Or,
};

AndOp: Opcode = {
    "and" => Opcode::And,
};

CompareOp: Opcode = {
    "==" => Opcode::Eq,
    "!=" => Opcode::Neq,
    "<=" => Opcode::Lte,
    ">=" => Opcode::Gte,
};

AddOp: Opcode = { 
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

MulOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

BottomExpr: Box<Expr> = {
    "null" => Box::new(Expr::Null),
    Str    => Box::new(Expr::Str(<>)),
    Bool   => Box::new(Expr::Bool(<>)),
    Number => Box::new(Expr::Number(<>)),
    Float  => Box::new(Expr::Float(<>)),
    ID     => Box::new(Expr::ID(<>)),
    Col    => Box::new(Expr::Col(<>)),
    Array  => Box::new(Expr::Array(<>)),
    Object => Box::new(Expr::Object(<>)),
    <id:ID> "(" <args:Args> ")" => Box::new(Expr::App(id, args)),
    "(" <TopExpr> ")",
};

Object: Vec<(String, Box<Expr>)> = {
   "{" <ObjItems> "}",
};

Array: Vec<Box<Expr>> = {
   "[" <Args> "]", 
};

Bool: bool = {
   "true" => true,
   "false" => false,
};

Str: String = {
     SINGLESTRING => String::from(&<>[1..<>.len()-1]),
     DOUBLESTRING => String::from(&<>[1..<>.len()-1]),
};

Number: i64 = {
     INT => i64::from_str(<>).unwrap(),
};

Float: f64 = {
     FLOAT => f64::from_str(<>).unwrap(),
};

Col: String = {
     COLUMN => String::from(<>),
};

ID: String = {
     VARIABLE => String::from(<>),
};
