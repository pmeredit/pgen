use std::str::FromStr;
use ast::{Expr, Opcode, Let, Cond, Switch};

grammar;

Assignments = List<Assignment, ",">;
Args = List<Expr, ",">;
Cases = List<Case, ",">;

List<T, Sep>: Vec<T> = { // (0)
    <v:(<T> Sep)*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier
};


pub TopExpr: Box<Expr> =  { 
    Expr,
    "let" <a:Assignments> "in" <e:TopExpr> => 
 	Box::new(Expr::Let(
	    Box::new(Let{assignments: a, expr: e}))),
    "if" <i:Expr> "then" <t:Expr> "else" <e:Expr> =>
     	Box::new(Expr::Cond(
	    Box::new(Cond{cond:i, then:t, otherwise:e}))),
    "switch" "{"  <c:Cases> "default" ":" <d:Expr> "}" =>
    	Box::new(Expr::Switch(
	    Box::new(Switch{cases:c, default:d}))),
};

Expr = Tier<ExprOp, Factor>;
Factor = Tier<FactorOp, Term>;

Assignment: (String, Box<Expr>) = {
    <id:ID> "=" <val:Expr> => (id, val)
};

Case: (Box<Expr>, Box<Expr>) = {
    <c:Expr> "=>" <e:Expr> => (c,e)
};

ExprOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Term: Box<Expr> = {
    Bool => Box::new(Expr::Bool(<>)),
    Num => Box::new(Expr::Number(<>)),
    ID  => Box::new(Expr::ID(<>)),
    Col => Box::new(Expr::Col(<>)),
    <id:ID> "(" <args:Args> ")" => Box::new(Expr::App(id, args)),
    "(" <TopExpr> ")",
};

Bool: bool = {
   "true" => true,
   "false" => false,
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Col: String = {
    r"\$\w+" => String::from(<>)
};

ID: String = {
    r"[a-zA-Z_]\w*" => String::from(<>)
};
