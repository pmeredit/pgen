use std::str::FromStr;
use ast::{Expr, Opcode, Let, Cond, Switch};

grammar;

Assignments = List<Assignment, ",">;
Args = List<TopExpr, ",">;
Cases = List<Case, ",">;

List<T, Sep>: Vec<T> = { 
    <v:(<T> Sep)*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier
};


pub TopExpr: Box<Expr> =  { 
    "let" <a:Assignments> "in" <e:TopExpr> => 
 	Box::new(Expr::Let(
	    Box::new(Let{assignments: a, expr: e}))),
    "if" <i:OrExpr> "then" <t:OrExpr> "else" <e:OrExpr> =>
     	Box::new(Expr::Cond(
	    Box::new(Cond{cond:i, then:t, otherwise:e}))),
    "switch" "{"  <c:Cases> "default" ":" <d:OrExpr> "}" =>
    	Box::new(Expr::Switch(
	    Box::new(Switch{cases:c, default:d}))),
    OrExpr,
};

OrExpr      = Tier<OrOp,      AndExpr     >;
AndExpr     = Tier<AndOp,     CompareExpr >;
CompareExpr = Tier<CompareOp, AddExpr     >;
AddExpr     = Tier<AddOp,     MulExpr     >;
MulExpr     = Tier<MulOp,     BottomExpr  >;

Assignment: (String, Box<Expr>) = {
    <id:ID> "=" <val:OrExpr> => (id, val)
};

Case: (Box<Expr>, Box<Expr>) = {
    <c:OrExpr> "=>" <e:OrExpr> => (c,e)
};

OrOp: Opcode = {
    "or" => Opcode::Or,
};

AndOp: Opcode = {
    "and" => Opcode::And,
};

CompareOp: Opcode = {
    "==" => Opcode::Eq,
    "!=" => Opcode::Neq,
    "<=" => Opcode::Lte,
    ">=" => Opcode::Gte,
};

AddOp: Opcode = { 
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

MulOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

BottomExpr: Box<Expr> = {
    "null" => Box::new(Expr::Null),
    Str    => Box::new(Expr::Str(<>)),
    Bool   => Box::new(Expr::Bool(<>)),
    Num    => Box::new(Expr::Number(<>)),
    ID     => Box::new(Expr::ID(<>)),
    Col    => Box::new(Expr::Col(<>)),
    <id:ID> "(" <args:Args> ")" => Box::new(Expr::App(id, args)),
    "(" <TopExpr> ")",
};

Str: String = {
   // '\'' panics lalrpop, so we have to use \u{0027} for a single quote
   r"'.*'" => String::from(<>.trim_matches('\u{0027}'))
};

Bool: bool = {
   "true" => true,
   "false" => false,
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Col: String = {
    r"\$\w+" => String::from(<>)
};

ID: String = {
    r"[a-zA-Z_]\w*" => String::from(<>)
};
